# ==========================================================
# PROYECTO INTEGRADOR - Análisis de Datos (versión Colab)
# Autor: <tu nombre>
# Descripción:
#   Programa de línea de comandos (interactivo) para:
#   - Cargar 1 o 2 archivos CSV (o usar datasets de ejemplo)
#   - Estadísticas (usando ≥2 columnas o cruce de 2 archivos)
#   - Reportes/Resúmenes (agrupaciones, top-N, crosstab)
#   - Gráficas (Matplotlib), con guardado a /output (puntos extra)
#   - Escritura de "resumen.txt" con ≥5 hallazgos (puntos extra)
#
# Requisitos didácticos cubiertos:
#   * Tipos básicos, operadores, condicionales (if), ciclos (for/while)
#   * Funciones (programación modular)
#   * Lectura y ESCRITURA de archivos de texto
#   * Estructuras: listas, listas de listas (matriz), tuplas, diccionarios y conjuntos
#   * Librerías investigadas: pandas (lectura de CSV), matplotlib (gráficas)
#
# Instrucciones (Colab):
#   1) Ejecuta esta celda.
#   2) En el menú, puedes:
#       - Usar datasets de ejemplo (rápido para pruebas)
#       - Subir tus CSV (files.upload()) o dar ruta/Drive
#   3) Explora las opciones de Estadísticas, Reportes y Gráficas.
#   4) Guarda el resumen (opción 4) para puntos extra.
#   5) Revisa /output para ver PNG de gráficas y resumen.txt
# ==========================================================

import os
import sys
import io
import csv
import math
from typing import List, Tuple, Dict, Set

# Librerías investigadas
import pandas as pd
import matplotlib.pyplot as plt

# Soporte Colab (subida de archivos). No falla si no estás en Colab.
try:
    from google.colab import files  # type: ignore
    IN_COLAB = True
except Exception:
    IN_COLAB = False

# ----------------------------
# Utilidades de archivos
# ----------------------------
def ensure_dir(path: str) -> None:
    """Crea carpeta si no existe."""
    if not os.path.exists(path):
        os.makedirs(path)

OUTPUT_DIR = "output"
DATA_DIR = "data"
ensure_dir(OUTPUT_DIR)
ensure_dir(DATA_DIR)

def detectar_delimitador(ruta: str, sample_size: int = 2048) -> str:
    """Detecta el delimitador probable del CSV usando csv.Sniffer."""
    with open(ruta, "r", newline="", encoding="utf-8") as f:
        sample = f.read(sample_size)
        sniffer = csv.Sniffer()
        try:
            dialect = sniffer.sniff(sample, delimiters=[",",";","|","\t"])
            return dialect.delimiter
        except Exception:
            return ","  # por defecto

def cargar_csv(ruta: str) -> pd.DataFrame:
    """Carga CSV con pandas detectando delimitador y cabeceras."""
    delim = detectar_delimitador(ruta)
    try:
        df = pd.read_csv(ruta, delimiter=delim, encoding="utf-8")
    except UnicodeDecodeError:
        df = pd.read_csv(ruta, delimiter=delim, encoding="latin-1")
    return df

def subir_csv_colab() -> Dict[str, io.BytesIO]:
    """Sube archivos en Colab, regresando dict nombre->contenido."""
    if not IN_COLAB:
        print("Subida Colab no disponible fuera de Colab.")
        return {}
    print("Selecciona 1 o 2 archivos .csv")
    return files.upload()

# ----------------------------
# Datasets de ejemplo (para plan de pruebas)
# ----------------------------
def crear_datasets_ejemplo() -> Tuple[str, str]:
    """
    Genera dos CSV sencillos:
      - salud.csv: id, edad, sexo, comorbilidad, positivo_covid (0/1)
      - clima.csv: id_estacion, fecha, temp_c, humedad, lluvia_mm
    Retorna rutas de los archivos creados.
    """
    salud_path = os.path.join(DATA_DIR, "salud.csv")
    clima_path = os.path.join(DATA_DIR, "clima.csv")

    if not os.path.exists(salud_path):
        with open(salud_path, "w", encoding="utf-8", newline="") as f:
            w = csv.writer(f)
            w.writerow(["id","edad","sexo","comorbilidad","positivo_covid"])
            # id, edad, sexo, comorbilidad, positivo(0/1)
            w.writerows([
                [1, 18, "F", "ninguna", 0],
                [2, 42, "M", "diabetes", 1],
                [3, 35, "F", "asma", 1],
                [4, 60, "M", "cardiovascular", 1],
                [5, 27, "M", "ninguna", 0],
                [6, 50, "F", "obesidad", 1],
                [7, 33, "M", "ninguna", 0],
                [8, 46, "F", "hipertension", 1],
                [9, 29, "F", "asma", 0],
                [10,55, "M", "diabetes", 1],
            ])

    if not os.path.exists(clima_path):
        with open(clima_path, "w", encoding="utf-8", newline="") as f:
            w = csv.writer(f)
            w.writerow(["id_estacion","fecha","temp_c","humedad","lluvia_mm"])
            # id_estacion, fecha, temp, humedad, lluvia
            w.writerows([
                [101,"2024-01-01", 22.5, 55, 0.0],
                [101,"2024-01-02", 21.2, 60, 1.2],
                [101,"2024-01-03", 20.0, 62, 0.0],
                [101,"2024-01-04", 19.5, 70, 4.6],
                [101,"2024-01-05", 23.0, 52, 0.0],
                [102,"2024-01-01", 24.1, 50, 0.0],
                [102,"2024-01-02", 23.8, 53, 0.0],
                [102,"2024-01-03", 22.0, 58, 2.0],
                [102,"2024-01-04", 21.2, 65, 6.0],
                [102,"2024-01-05", 25.0, 48, 0.0],
            ])
    return salud_path, clima_path

# ----------------------------
# Utilidades de columnas y filtros
# ----------------------------
def columnas_numericas(df: pd.DataFrame) -> List[str]:
    return [c for c in df.columns if pd.api.types.is_numeric_dtype(df[c])]

def columnas_categoricas(df: pd.DataFrame) -> List[str]:
    # incluye object y category
    return [c for c in df.columns if df[c].dtype == "object" or pd.api.types.is_categorical_dtype(df[c])]

def seleccionar_opcion(opciones: List[str], mensaje: str) -> int:
    """
    Muestra opciones enumeradas y retorna índice elegido.
    Usa while para validar.
    """
    while True:
        print("\n" + mensaje)
        for i, o in enumerate(opciones, start=1):
            print(f"{i}) {o}")
        sel = input("> ").strip()
        if sel.isdigit():
            idx = int(sel) - 1
            if 0 <= idx < len(opciones):
                return idx
        print("Selección inválida. Intenta otra vez.")

def pedir_columna(df: pd.DataFrame, cols: List[str], mensaje: str) -> str:
    idx = seleccionar_opcion(cols, mensaje)
    return cols[idx]

def aplicar_filtro_simple(df: pd.DataFrame) -> pd.DataFrame:
    """
    Permite filtro rápido:
      - igualdad para categórica
      - rango [min, max] para numérica
    """
    print("\n¿Deseas aplicar un filtro? 1) Sí  2) No")
    op = input("> ").strip()
    if op != "1":
        return df

    cols = df.columns.tolist()
    col = cols[seleccionar_opcion(cols, "Selecciona columna para filtrar:")]
    serie = df[col]
    if pd.api.types.is_numeric_dtype(serie):
        try:
            vmin = float(input("Valor mínimo: ").strip())
            vmax = float(input("Valor máximo: ").strip())
            df2 = df[(serie >= vmin) & (serie <= vmax)]
            print(f"Filtrado numérico: {len(df2)} filas.")
            return df2
        except Exception:
            print("Filtro inválido. No se aplicó.")
            return df
    else:
        val = input(f"Valor exacto a igualar en '{col}': ").strip()
        df2 = df[serie.astype(str) == val]
        print(f"Filtrado categórico: {len(df2)} filas.")
        return df2

# ----------------------------
# Hallazgos (resumen.txt)
# ----------------------------
HALLAZGOS: List[str] = []

def agregar_hallazgo(texto: str) -> None:
    """Agrega hallazgo al resumen (usa lista global)."""
    HALLAZGOS.append(str(texto))

def guardar_resumen() -> None:
    """
    Escribe al menos 5 hallazgos en output/resumen.txt.
    """
    if len(HALLAZGOS) < 5:
        print(f"Solo tienes {len(HALLAZGOS)} hallazgos. Se recomiendan ≥5 para puntos extra.")
    ruta = os.path.join(OUTPUT_DIR, "resumen.txt")
    with open(ruta, "w", encoding="utf-8") as f:
        f.write("RESUMEN DE HALLAZGOS\n")
        f.write("====================\n\n")
        for i, h in enumerate(HALLAZGOS, 1):
            f.write(f"{i}. {h}\n")
    print(f"Resumen guardado en: {ruta}")

# ----------------------------
# Estadísticas
# ----------------------------
def estadistica_correlacion(df: pd.DataFrame) -> None:
    """
    Correlación Pearson entre dos columnas numéricas.
    Usa ≥2 columnas (cumple requisito).
    """
    df_work = aplicar_filtro_simple(df)
    nums = columnas_numericas(df_work)
    if len(nums) < 2:
        print("Se requieren ≥2 columnas numéricas.")
        return
    xcol = pedir_columna(df_work, nums, "Elige la columna X (numérica):")
    ycol = pedir_columna(df_work, nums, "Elige la columna Y (numérica):")
    sub = df_work[[xcol, ycol]].dropna()
    if sub.empty:
        print("Sin datos tras dropna.")
        return
    corr = sub[xcol].corr(sub[ycol])
    print(f"Correlación Pearson({xcol}, {ycol}) = {corr:.4f}")
    agregar_hallazgo(f"Correlación({xcol},{ycol}) = {corr:.4f}")

def estadistica_categoria_media(df: pd.DataFrame) -> None:
    """
    Media de una variable numérica por categoría (agrupación).
    Usa ≥2 columnas: categórica + numérica.
    """
    df_work = aplicar_filtro_simple(df)
    cats = columnas_categoricas(df_work)
    nums = columnas_numericas(df_work)
    if not cats or not nums:
        print("Se requiere al menos 1 categórica y 1 numérica.")
        return
    ccol = pedir_columna(df_work, cats, "Elige la columna categórica:")
    ncol = pedir_columna(df_work, nums, "Elige la columna numérica a promediar:")
    tabla = df_work.groupby(ccol)[ncol].mean().sort_values(ascending=False)
    print("\nMedia por categoría:")
    print(tabla.head(20))
    top_cat = tabla.index[0]
    top_val = float(tabla.iloc[0])
    agregar_hallazgo(f"Mayor media de {ncol} en {ccol}='{top_cat}' con {top_val:.2f}")

def estadistica_cruce_dos_csv(df1: pd.DataFrame, df2: pd.DataFrame) -> None:
    """
    Cruza 2 archivos por una llave común y calcula correlación
    entre dos columnas numéricas de la tabla combinada.
    """
    if df2 is None:
        print("Necesitas 2 CSV cargados para esta opción.")
        return
    # Selección de llaves
    k1 = pedir_columna(df1, df1.columns.tolist(), "CSV1: elige columna llave para el MERGE:")
    k2 = pedir_columna(df2, df2.columns.tolist(), "CSV2: elige columna llave para el MERGE:")
    merged = pd.merge(df1, df2, left_on=k1, right_on=k2, how="inner")
    if merged.empty:
        print("Merge vacío. Llaves incompatibles.")
        return
    print(f"Merge OK. Filas combinadas: {len(merged)}")
    nums = columnas_numericas(merged)
    if len(nums) < 2:
        print("Tras el merge, se requieren ≥2 columnas numéricas.")
        return
    xcol = pedir_columna(merged, nums, "Elige X (numérica) de la combinada:")
    ycol = pedir_columna(merged, nums, "Elige Y (numérica) de la combinada:")
    sub = merged[[xcol, ycol]].dropna()
    corr = sub[xcol].corr(sub[ycol])
    print(f"Correlación tras cruce: Pearson({xcol},{ycol}) = {corr:.4f}")
    agregar_hallazgo(f"Merge[{k1}~{k2}] => Correlación({xcol},{ycol})={corr:.4f}")

def sub_estadisticas(df1: pd.DataFrame, df2: pd.DataFrame) -> None:
    while True:
        print("\n=== ESTADÍSTICAS ===")
        print("1) Correlación entre 2 numéricas (mismo CSV)")
        print("2) Media de numérica por categoría")
        print("3) Correlación tras CRUZAR 2 CSV")
        print("0) Volver")
        op = input("> ").strip()
        if op == "1":
            df = elegir_csv_para_operacion(df1, df2, "Elige CSV para correlación:")
            if df is not None:
                estadistica_correlacion(df)
        elif op == "2":
            df = elegir_csv_para_operacion(df1, df2, "Elige CSV para media por categoría:")
            if df is not None:
                estadistica_categoria_media(df)
        elif op == "3":
            if df1 is None or df2 is None:
                print("Debes tener 2 CSV cargados.")
            else:
                estadistica_cruce_dos_csv(df1, df2)
        elif op == "0":
            break
        else:
            print("Opción inválida.")

# ----------------------------
# Reportes
# ----------------------------
def reporte_valores_unicos(df: pd.DataFrame) -> None:
    """
    Reporte de valores únicos por una columna categórica.
    Usa conjuntos (set) y listas de listas (matriz) para mostrar.
    """
    cats = columnas_categoricas(df)
    if not cats:
        print("No hay columnas categóricas.")
        return
    ccol = pedir_columna(df, cats, "Elige columna categórica para valores únicos:")
    valores = set(df[ccol].dropna().astype(str).unique())  # conjunto
    print(f"\nValores únicos en {ccol} ({len(valores)}):")
    # Lista de listas (matriz) para impresión tabular 3 por fila
    matriz: List[List[str]] = []
    fila: List[str] = []
    for i, v in enumerate(sorted(valores)):
        fila.append(v)
        if (i+1) % 3 == 0:
            matriz.append(fila)
            fila = []
    if fila:
        matriz.append(fila)
    for fila in matriz:
        print(" | ".join(fila))
    agregar_hallazgo(f"{ccol} tiene {len(valores)} categorías distintas.")

def reporte_topN(df: pd.DataFrame) -> None:
    """
    Top-N categorías con mayor suma de una variable numérica.
    Usa diccionario para elegir agregación.
    """
    cats = columnas_categoricas(df)
    nums = columnas_numericas(df)
    if not cats or not nums:
        print("Se requiere categórica y numérica.")
        return
    ccol = pedir_columna(df, cats, "Columna categórica para agrupar:")
    ncol = pedir_columna(df, nums, "Columna numérica a agregar:")
    agg_ops: Dict[str, str] = {"1":"sum", "2":"mean", "3":"count"}
    print("Agregación: 1) Suma  2) Media  3) Conteo")
    agg_choice = input("> ").strip()
    agg = agg_ops.get(agg_choice, "sum")
    tabla = df.groupby(ccol)[ncol].agg(agg).sort_values(ascending=False)
    print("\nTop categorías:")
    print(tabla.head(10))
    if len(tabla) > 0:
        agregar_hallazgo(f"Top en {ccol} según {agg}({ncol}) = '{tabla.index[0]}'")

def reporte_crosstab(df: pd.DataFrame) -> None:
    """
    Crosstab entre dos categóricas (matriz de contingencia).
    Convierte a lista de listas para demostrar "matriz".
    """
    cats = columnas_categoricas(df)
    if len(cats) < 2:
        print("Se requieren al menos 2 categóricas.")
        return
    c1 = pedir_columna(df, cats, "Categórica 1:")
    c2 = pedir_columna(df, cats, "Categórica 2:")
    ct = pd.crosstab(df[c1], df[c2])
    print("\nCrosstab:\n", ct.head(20))
    matriz: List[List[float]] = ct.values.tolist()  # listas de listas
    agregar_hallazgo(f"Crosstab entre {c1} y {c2} generado (tamaño {ct.shape}).")

def reporte_sets_entre_csv(df1: pd.DataFrame, df2: pd.DataFrame) -> None:
    """
    Si hay 2 CSV: muestra intersección y diferencias de categorías
    entre una columna de df1 y otra de df2 (uso de conjuntos).
    """
    if df2 is None:
        print("Requiere 2 CSV.")
        return
    c1 = pedir_columna(df1, df1.columns.tolist(), "CSV1: columna para SET:")
    c2 = pedir_columna(df2, df2.columns.tolist(), "CSV2: columna para SET:")
    s1: Set[str] = set(df1[c1].dropna().astype(str).unique())
    s2: Set[str] = set(df2[c2].dropna().astype(str).unique())
    inter = s1 & s2
    solo1 = s1 - s2
    solo2 = s2 - s1
    print(f"\nIntersección ({len(inter)}): {sorted(list(inter))[:20]}")
    print(f"Solo en CSV1 ({len(solo1)}): {sorted(list(solo1))[:20]}")
    print(f"Solo en CSV2 ({len(solo2)}): {sorted(list(solo2))[:20]}")
    agregar_hallazgo(f"Intersección entre {c1} y {c2}: {len(inter)} valores comunes.")

def sub_reportes(df1: pd.DataFrame, df2: pd.DataFrame) -> None:
    while True:
        print("\n=== REPORTES ===")
        print("1) Valores únicos (conjuntos) de una categórica")
        print("2) Top-N por agregación (sum/mean/count)")
        print("3) Crosstab entre 2 categóricas (matriz)")
        print("4) Comparar categorías entre 2 CSV (intersección/diferencias)")
        print("0) Volver")
        op = input("> ").strip()
        if op == "1":
            df = elegir_csv_para_operacion(df1, df2, "Elige CSV para valores únicos:")
            if df is not None:
                reporte_valores_unicos(df)
        elif op == "2":
            df = elegir_csv_para_operacion(df1, df2, "Elige CSV para Top-N:")
            if df is not None:
                reporte_topN(df)
        elif op == "3":
            df = elegir_csv_para_operacion(df1, df2, "Elige CSV para Crosstab:")
            if df is not None:
                reporte_crosstab(df)
        elif op == "4":
            if df1 is None or df2 is None:
                print("Necesitas 2 CSV cargados.")
            else:
                reporte_sets_entre_csv(df1, df2)
        elif op == "0":
            break
        else:
            print("Opción inválida.")

# ----------------------------
# Gráficas (Matplotlib)
# ----------------------------
def grafica_linea(df: pd.DataFrame) -> None:
    """
    Línea de una numérica vs índice o vs otra columna numérica/fecha.
    Guarda PNG en output/.
    """
    df_work = aplicar_filtro_simple(df)
    nums = columnas_numericas(df_work)
    cols = df_work.columns.tolist()
    if not nums:
        print("Se requiere al menos 1 numérica.")
        return
    ycol = pedir_columna(df_work, nums, "Y (numérica) para línea:")
    print("¿Usar X explícita? 1) Sí  2) No (índice)")
    op = input("> ").strip()
    if op == "1":
        xcol = pedir_columna(df_work, cols, "X (columna):")
        x = df_work[xcol]
    else:
        x = df_work.index
    y = df_work[ycol]
    plt.figure()
    plt.plot(x, y)
    plt.title(f"Línea: {ycol} vs X")
    plt.xlabel("X")
    plt.ylabel(ycol)
    ruta = os.path.join(OUTPUT_DIR, f"grafica_linea_{ycol}.png")
    plt.savefig(ruta, bbox_inches="tight", dpi=120)
    plt.show()
    print(f"Guardada: {ruta}")
    agregar_hallazgo(f"Gráfica de línea guardada para {ycol}.")

def grafica_barras(df: pd.DataFrame) -> None:
    """
    Barras: agregación de una numérica por categoría.
    """
    cats = columnas_categoricas(df)
    nums = columnas_numericas(df)
    if not cats or not nums:
        print("Se requiere categórica y numérica.")
        return
    ccol = pedir_columna(df, cats, "Categórica (eje X):")
    ncol = pedir_columna(df, nums, "Numérica (a agregar):")
    print("Agregación: 1) Suma  2) Media  3) Conteo")
    agg_choice = input("> ").strip()
    if agg_choice == "2":
        serie = df.groupby(ccol)[ncol].mean().sort_values(ascending=False).head(12)
        agg_name = "media"
    elif agg_choice == "3":
        serie = df.groupby(ccol)[ncol].count().sort_values(ascending=False).head(12)
        agg_name = "conteo"
    else:
        serie = df.groupby(ccol)[ncol].sum().sort_values(ascending=False).head(12)
        agg_name = "suma"
    plt.figure(figsize=(8,4))
    serie.plot(kind="bar")
    plt.title(f"Barras: {agg_name}({ncol}) por {ccol}")
    plt.xlabel(ccol)
    plt.ylabel(f"{agg_name}({ncol})")
    ruta = os.path.join(OUTPUT_DIR, f"grafica_barras_{ccol}_{ncol}.png")
    plt.savefig(ruta, bbox_inches="tight", dpi=120)
    plt.show()
    print(f"Guardada: {ruta}")
    agregar_hallazgo(f"Barras: top categorías por {agg_name}({ncol}).")

def grafica_dispersion(df: pd.DataFrame) -> None:
    """
    Dispersión entre 2 columnas numéricas con correlación en el título.
    """
    df_work = aplicar_filtro_simple(df)
    nums = columnas_numericas(df_work)
    if len(nums) < 2:
        print("Se requieren ≥2 numéricas.")
        return
    xcol = pedir_columna(df_work, nums, "X (numérica):")
    ycol = pedir_columna(df_work, nums, "Y (numérica):")
    sub = df_work[[xcol, ycol]].dropna()
    corr = sub[xcol].corr(sub[ycol])
    plt.figure()
    plt.scatter(sub[xcol], sub[ycol])
    plt.title(f"Dispersión: {xcol} vs {ycol} (r={corr:.2f})")
    plt.xlabel(xcol); plt.ylabel(ycol)
    ruta = os.path.join(OUTPUT_DIR, f"grafica_disp_{xcol}_{ycol}.png")
    plt.savefig(ruta, bbox_inches="tight", dpi=120)
    plt.show()
    print(f"Guardada: {ruta}")
    agregar_hallazgo(f"Dispersión {xcol}~{ycol} (r={corr:.2f}).")

def sub_graficas(df1: pd.DataFrame, df2: pd.DataFrame) -> None:
    while True:
        print("\n=== GRÁFICAS ===")
        print("1) Línea (Y vs X o índice)")
        print("2) Barras (agrupación categórica)")
        print("3) Dispersión (X vs Y)")
        print("0) Volver")
        op = input("> ").strip()
        if op == "1":
            df = elegir_csv_para_operacion(df1, df2, "Elige CSV para línea:")
            if df is not None:
                grafica_linea(df)
        elif op == "2":
            df = elegir_csv_para_operacion(df1, df2, "Elige CSV para barras:")
            if df is not None:
                grafica_barras(df)
        elif op == "3":
            df = elegir_csv_para_operacion(df1, df2, "Elige CSV para dispersión:")
            if df is not None:
                grafica_dispersion(df)
        elif op == "0":
            break
        else:
            print("Opción inválida.")

# ----------------------------
# Elección de CSV y carga
# ----------------------------
def elegir_csv_para_operacion(df1: pd.DataFrame, df2: pd.DataFrame, mensaje: str) -> pd.DataFrame:
    opciones = []
    if df1 is not None:
        opciones.append("CSV 1")
    if df2 is not None:
        opciones.append("CSV 2")
    if not opciones:
        print("No hay CSV cargados.")
        return None
    idx = seleccionar_opcion(opciones, mensaje)
    if opciones[idx] == "CSV 1":
        return df1
    else:
        return df2

def cargar_datasets_interactivo() -> Tuple[pd.DataFrame, pd.DataFrame]:
    """
    Devuelve (df1, df2). df2 puede ser None.
    Opciones: ejemplo, subir archivos Colab, o ruta manual.
    """
    print("\nCARGA DE DATOS")
    print("1) Usar datasets de ejemplo")
    print("2) Subir CSV (Colab)")
    print("3) Dar ruta local (o montada)")
    elec = input("> ").strip()

    df1 = None
    df2 = None

    if elec == "1":
        p1, p2 = crear_datasets_ejemplo()
        df1 = cargar_csv(p1)
        df2 = cargar_csv(p2)
        print(f"Ejemplos cargados: {p1} ({len(df1)} filas), {p2} ({len(df2)} filas)")
    elif elec == "2":
        if not IN_COLAB:
            print("Subida no disponible fuera de Colab. Usa opción 3.")
        else:
            up = subir_csv_colab()
            rutas = []
            for nombre, data in up.items():
                ruta = os.path.join(DATA_DIR, nombre)
                with open(ruta, "wb") as f:
                    f.write(data.read())
                rutas.append(ruta)
            if len(rutas) == 0:
                print("No subiste archivos.")
            elif len(rutas) == 1:
                df1 = cargar_csv(rutas[0])
                print(f"Cargado: {rutas[0]} ({len(df1)} filas)")
            else:
                df1 = cargar_csv(rutas[0])
                df2 = cargar_csv(rutas[1])
                print(f"Cargados: {rutas[0]} ({len(df1)}), {rutas[1]} ({len(df2)})")
    elif elec == "3":
        ruta1 = input("Ruta a CSV 1: ").strip()
        df1 = cargar_csv(ruta1)
        print(f"Cargado CSV1 ({len(df1)} filas).")
        print("¿Cargar un segundo CSV? 1) Sí  2) No")
        if input("> ").strip() == "1":
            ruta2 = input("Ruta a CSV 2: ").strip()
            df2 = cargar_csv(ruta2)
            print(f"Cargado CSV2 ({len(df2)} filas).")
    else:
        print("Opción inválida. Usando datasets de ejemplo por defecto.")
        p1, p2 = crear_datasets_ejemplo()
        df1 = cargar_csv(p1)
        df2 = cargar_csv(p2)

    return df1, df2

# ----------------------------
# Menú principal
# ----------------------------
def main():
    print("=== PROYECTO INTEGRADOR: Análisis de Datos ===")
    df1, df2 = cargar_datasets_interactivo()

    # Tuplas: ejemplo simple de metadatos inmutables
    info: Tuple[str, str] = ("Versión", "1.0")
    print(f"{info[0]} del programa: {info[1]}")

    while True:
        print("\nMENÚ PRINCIPAL")
        print("1) Estadísticas")
        print("2) Reportes")
        print("3) Gráficas")
        print("4) Guardar resumen (TXT)  [puntos extra]")
        print("0) Salir")
        op = input("> ").strip()

        if op == "1":
            sub_estadisticas(df1, df2)
        elif op == "2":
            sub_reportes(df1, df2)
        elif op == "3":
            sub_graficas(df1, df2)
        elif op == "4":
            guardar_resumen()
        elif op == "0":
            print("Adiós.")
            break
        else:
            print("Opción inválida.")

# Ejecutar programa
if __name__ == "__main__":
    main()
