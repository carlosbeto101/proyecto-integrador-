# ============================================================
# PROYECTO INTEGRADOR - ANÁLISIS DE DATOS DEMOGRÁFICOS (COMPLETO)
# Estilo y lógica: mantiene el flujo del compañero (menús y funciones).
# Mejores prácticas añadidas para cubrir rúbrica y extras.
# ============================================================

import os
import pandas as pd
import matplotlib.pyplot as plt

# Intento de usar kagglehub si está disponible (como en el código del compañero)
try:
    import kagglehub
    KAGGLE_OK = True
except Exception:
    KAGGLE_OK = False

# -------------------------------
# CONFIGURACIÓN Y ESTRUCTURAS
# -------------------------------
OUTPUT_DIR = "output"
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Tupla (inmutable) para evidenciar uso de tuplas en el programa
VERSION_INFO = ("Programa", "1.1")

# Diccionario para mapear agregaciones en reportes/gráficas
AGG_MAP = {"1": "sum", "2": "mean", "3": "count"}

# Lista global de hallazgos para el resumen.txt
HALLAZGOS = []

# DataFrames globales (como en el código del compañero)
df = None      # dataset principal
df2 = None     # dataset secundario opcional para merge


# -------------------------------
# UTILIDADES Y VALIDACIONES
# -------------------------------
def leer_csv_generico(ruta):
    """
    Intenta leer CSV con inferencia de separador.
    Hace fallback de encoding a latin-1 si es necesario.
    """
    try:
        return pd.read_csv(ruta, sep=None, engine="python")
    except UnicodeDecodeError:
        return pd.read_csv(ruta, sep=None, engine="python", encoding="latin-1")

def input_opcion(msg, opciones_validas):
    """Lee una opción del usuario y valida."""
    while True:
        op = input(msg).strip()
        if op in opciones_validas:
            return op
        print("Opción no válida.")

def input_int(msg):
    """Pide entero con validación simple."""
    while True:
        s = input(msg).strip()
        try:
            return int(s)
        except ValueError:
            print("Ingresa un número entero válido.")

def columnas_numericas(dframe):
    return [c for c in dframe.columns if pd.api.types.is_numeric_dtype(dframe[c])]

def columnas_categoricas(dframe):
    return [c for c in dframe.columns if dframe[c].dtype == "object" or pd.api.types.is_categorical_dtype(dframe[c])]

def aplicar_filtro_simple(dframe):
    """
    Filtro configurable:
    - Si la columna es numérica: rango [min, max]
    - Si es categórica: igualdad exacta
    """
    print("\n¿Deseas aplicar filtro? 1) Sí  2) No")
    if input_opcion("> ", {"1","2"}) == "2":
        return dframe

    cols = dframe.columns.tolist()
    print("Elige columna para filtrar:")
    for i, c in enumerate(cols, start=1):
        print(f"{i}. {c}")
    idx = input_int("> ") - 1
    if idx < 0 or idx >= len(cols):
        print("Selección inválida. Sin filtro.")
        return dframe

    col = cols[idx]
    serie = dframe[col]
    if pd.api.types.is_numeric_dtype(serie):
        vmin = input_int("Valor mínimo: ")
        vmax = input_int("Valor máximo: ")
        if vmin > vmax:
            vmin, vmax = vmax, vmin
        dfx = dframe[(serie >= vmin) & (serie <= vmax)]
        print(f"Filtrado numérico aplicado. Filas: {len(dfx)}")
        return dfx
    else:
        val = input(f"Valor exacto para '{col}': ").strip()
        dfx = dframe[serie.astype(str) == val]
        print(f"Filtrado categórico aplicado. Filas: {len(dfx)}")
        return dfx

def agregar_hallazgo(texto):
    """Registra un hallazgo para el resumen."""
    HALLAZGOS.append(str(texto))

def guardar_resumen_txt():
    """
    Escribe output/resumen.txt con ≥5 hallazgos.
    """
    ruta = os.path.join(OUTPUT_DIR, "resumen.txt")
    with open(ruta, "w", encoding="utf-8") as f:
        f.write("RESUMEN DE HALLAZGOS\n")
        f.write("====================\n\n")
        if len(HALLAZGOS) == 0:
            f.write("No se registraron hallazgos.\n")
        else:
            for i, h in enumerate(HALLAZGOS, 1):
                f.write(f"{i}. {h}\n")
    print(f"\nResumen guardado en: {ruta}")
    if len(HALLAZGOS) < 5:
        print("Sugerencia: agrega ≥5 hallazgos para asegurar los puntos extra.")


# -------------------------------
# CARGA DE DATOS
# -------------------------------
def cargar_dataset_principal():
    """
    Mantiene la lógica del compañero: descargar dataset de Kaggle si es posible.
    Si no, pide ruta local.
    """
    global df
    if KAGGLE_OK:
        print("Descargando dataset de Kaggle...")
        path = kagglehub.dataset_download("nipunarora8/age-gender-and-ethnicity-face-data-csv")
        print("Archivos descargados en:", path)
        print(os.listdir(path))
        file_name = "age_gender.csv"
        df = pd.read_csv(f"{path}/{file_name}")
    else:
        ruta = input("Ruta a CSV principal: ").strip()
        df = leer_csv_generico(ruta)

    print("\nPrimeras filas del dataset:")
    print(df.head())
    print("Columnas disponibles:", df.columns.tolist())

def cargar_dataset_secundario():
    """
    Permite cargar un segundo CSV opcional (para merge).
    """
    global df2
    ruta = input("Ruta a CSV secundario para cruce (merge): ").strip()
    if not ruta:
        print("Ruta vacía. No se cargó segundo CSV.")
        return
    try:
        df2 = leer_csv_generico(ruta)
        print("CSV secundario cargado. Columnas:", df2.columns.tolist())
        print(df2.head())
    except Exception as e:
        print("No se pudo cargar el CSV secundario:", e)


# -------------------------------
# ESTADÍSTICAS
# -------------------------------
def estadistica():
    global df, df2

    while True:
        print("\n Datos Demográficos (ESTADÍSTICAS) ")
        print("1. Promedio de edad por género")
        print("2. Promedio de edad por etnia")
        print("3. Promedio de edad por género y etnia (cruce de columnas)")
        print("4. Correlación entre dos columnas numéricas")
        print("5. Correlación tras MERGE de 2 CSV (llaves configurables)")
        print("6. Volver al menú principal")
        opcion = input_opcion("Elige una opción: ", {"1","2","3","4","5","6"})

        if opcion == "1":
            dfx = aplicar_filtro_simple(df)
            if "gender" not in dfx.columns or "age" not in dfx.columns:
                print("El dataset no tiene columnas 'gender' y 'age'.")
                continue
            res = dfx.groupby("gender")["age"].mean().sort_values(ascending=False)
            print("\nPromedio de edad por género:")
            print(res)
            top = res.index[0]
            agregar_hallazgo(f"Mayor promedio de edad en género={top} con {res.iloc[0]:.2f} años.")

        elif opcion == "2":
            dfx = aplicar_filtro_simple(df)
            if "ethnicity" not in dfx.columns or "age" not in dfx.columns:
                print("El dataset no tiene columnas 'ethnicity' y 'age'.")
                continue
            res = dfx.groupby("ethnicity")["age"].mean().sort_values(ascending=False)
            print("\nPromedio de edad por etnia:")
            print(res)
            top = res.index[0]
            agregar_hallazgo(f"Etnia con mayor edad promedio: {top} ({res.iloc[0]:.2f} años).")

        elif opcion == "3":
            dfx = aplicar_filtro_simple(df)
            if not set(["gender","ethnicity","age"]).issubset(dfx.columns):
                print("Faltan columnas 'gender', 'ethnicity' o 'age'.")
                continue
            res = dfx.groupby(["gender","ethnicity"])["age"].mean().unstack()
            print("\nPromedio de edad por género y etnia:")
            print(res)
            agregar_hallazgo("Se generó tabla de medias de edad por género×etnia.")

        elif opcion == "4":
            dfx = aplicar_filtro_simple(df)
            nums = columnas_numericas(dfx)
            if len(nums) < 2:
                print("Se requieren al menos 2 columnas numéricas.")
                continue

            print("Columnas numéricas disponibles:", nums)
            x = input("Elige la primera columna: ").strip()
            y = input("Elige la segunda columna: ").strip()
            if x not in nums or y not in nums:
                print("Selección inválida.")
                continue
            sub = dfx[[x, y]].dropna()
            if sub.empty:
                print("Sin datos suficientes.")
                continue
            r = sub[x].corr(sub[y])
            print(f"Correlación Pearson({x}, {y}) = {r:.4f}")
            agregar_hallazgo(f"Correlación({x},{y})={r:.4f} en dataset principal.")

        elif opcion == "5":
            if df2 is None:
                print("No hay CSV secundario cargado. Ve a 'Configurar datos' y carga uno.")
                continue
            print("Llave para CSV principal (df):")
            print(df.columns.tolist())
            k1 = input("> ").strip()
            print("Llave para CSV secundario (df2):")
            print(df2.columns.tolist())
            k2 = input("> ").strip()
            if k1 not in df.columns or k2 not in df2.columns:
                print("Llaves inválidas.")
                continue
            merged = pd.merge(df, df2, left_on=k1, right_on=k2, how="inner")
            if merged.empty:
                print("Merge vacío. Llaves incompatibles.")
                continue
            print("Merge ok. Filas combinadas:", len(merged))
            nums = columnas_numericas(merged)
            if len(nums) < 2:
                print("Tras merge, se requieren 2 numéricas.")
                continue
            print("Numéricas combinadas:", nums)
            x = input("Elige X: ").strip()
            y = input("Elige Y: ").strip()
            if x not in nums or y not in nums:
                print("Selección inválida.")
                continue
            sub = merged[[x, y]].dropna()
            if sub.empty:
                print("Sin datos tras limpieza.")
                continue
            r = sub[x].corr(sub[y])
            print(f"Correlación Pearson({x}, {y}) en MERGE = {r:.4f}")
            agregar_hallazgo(f"Merge[{k1}~{k2}] -> r({x},{y})={r:.4f}")

        elif opcion == "6":
            break


# -------------------------------
# REPORTES (incluye sets y matriz)
# -------------------------------
def reporte():
    global df, df2

    while True:
        print("\n MENÚ DE REPORTES ")
        print("1. Conteo de personas por género")
        print("2. Conteo de personas por etnia")
        print("3. Reporte de edades por rango (configurable)")
        print("4. Crosstab entre dos categóricas (lista de listas)")
        print("5. Comparar categorías entre df y df2 (conjuntos)")
        print("6. Volver al menú principal")
        opcion = input_opcion("Elige una opción: ", {"1","2","3","4","5","6"})

        if opcion == "1":
            if "gender" not in df.columns:
                print("No existe columna 'gender'.")
                continue
            conteo = df["gender"].value_counts()
            print("\nNúmero de personas por género:")
            print(conteo)
            agregar_hallazgo(f"Conteo por género: total categorías = {len(conteo)}")

        elif opcion == "2":
            if "ethnicity" not in df.columns:
                print("No existe columna 'ethnicity'.")
                continue
            conteo = df["ethnicity"].value_counts()
            print("\nNúmero de personas por etnia:")
            print(conteo)
            agregar_hallazgo(f"Conteo por etnia: total categorías = {len(conteo)}")

        elif opcion == "3":
            if "age" not in df.columns:
                print("No existe columna 'age'.")
                continue
            edadmin = input_int("Edad mínima: ")
            edadmax = input_int("Edad máxima: ")
            if edadmin > edadmax:
                edadmin, edadmax = edadmax, edadmin
            filtro = df[(df["age"] >= edadmin) & (df["age"] <= edadmax)]
            print(f"\nPersonas entre {edadmin} y {edadmax} años: {len(filtro)}")
            print(filtro.head())
            agregar_hallazgo(f"{len(filtro)} filas en rango de edad [{edadmin},{edadmax}].")

        elif opcion == "4":
            # Crosstab -> convertir a lista de listas (matriz)
            cats = columnas_categoricas(df)
            if len(cats) < 2:
                print("Se requieren al menos 2 categóricas.")
                continue
            print("Categóricas disponibles:", cats)
            c1 = input("Categórica 1: ").strip()
            c2 = input("Categórica 2: ").strip()
            if c1 not in cats or c2 not in cats:
                print("Selección inválida.")
                continue
            ct = pd.crosstab(df[c1], df[c2]).fillna(0).astype(int)
            print("\nCrosstab:")
            print(ct)

            # Conversión a lista de listas para evidenciar "matriz"
            matriz = ct.values.tolist()          # <-- listas de listas
            # Impresión simple de las primeras filas de la matriz
            print("\nMatriz (primeras filas):")
            for fila in matriz[:5]:
                print(fila)
            agregar_hallazgo(f"Crosstab {c1}×{c2} tamaño={ct.shape}")

        elif opcion == "5":
            if df2 is None:
                print("No hay CSV secundario cargado.")
                continue
            # Conjuntos: intersección y diferencias
            print("Columna categórica en df:")
            print(df.columns.tolist())
            col1 = input("> ").strip()
            print("Columna categórica en df2:")
            print(df2.columns.tolist())
            col2 = input("> ").strip()
            if col1 not in df.columns or col2 not in df2.columns:
                print("Selección inválida.")
                continue
            set1 = set(df[col1].dropna().astype(str).unique())
            set2 = set(df2[col2].dropna().astype(str).unique())
            inter = set1 & set2
            solo1 = set1 - set2
            solo2 = set2 - set1
            print(f"\nIntersección ({len(inter)}): {sorted(list(inter))[:20]}")
            print(f"Solo en df ({len(solo1)}): {sorted(list(solo1))[:20]}")
            print(f"Solo en df2 ({len(solo2)}): {sorted(list(solo2))[:20]}")
            agregar_hallazgo(f"Intersección {col1}~{col2}: {len(inter)} valores.")

        elif opcion == "6":
            break


# -------------------------------
# GRÁFICAS (guardar PNG >= 3)
# -------------------------------
def grafica():
    global df

    while True:
        print("\n MENÚ DE GRÁFICAS ")
        print("1. Gráfico de barras: distribución por género")
        print("2. Gráfico de pastel: distribución por etnia")
        print("3. Gráfico de barras: promedio de edad por etnia")
        print("4. Volver al menú principal")
        opcion = input_opcion("Elige una opción: ", {"1","2","3","4"})

        if opcion == "1":
            if "gender" not in df.columns:
                print("No existe columna 'gender'.")
                continue
            conteo = df["gender"].value_counts()
            ax = conteo.plot(kind="bar")
            ax.set_title("Distribución por género")
            ax.set_xlabel("Género (0 = Mujer, 1 = Hombre)")
            ax.set_ylabel("Cantidad de personas")
            ruta = os.path.join(OUTPUT_DIR, "graf_barras_genero.png")
            plt.savefig(ruta, dpi=120, bbox_inches="tight")
            plt.show()
            print(f"Gráfica guardada en: {ruta}")
            agregar_hallazgo("Gráfica de barras por género guardada.")

        elif opcion == "2":
            if "ethnicity" not in df.columns:
                print("No existe columna 'ethnicity'.")
                continue
            conteo = df["ethnicity"].value_counts()
            ax = conteo.plot(kind="pie", autopct="%1.1f%%")
            ax.set_ylabel("")
            ax.set_title("Distribución por etnia")
            ruta = os.path.join(OUTPUT_DIR, "graf_pastel_etnia.png")
            plt.savefig(ruta, dpi=120, bbox_inches="tight")
            plt.show()
            print(f"Gráfica guardada en: {ruta}")
            agregar_hallazgo("Gráfica de pastel por etnia guardada.")

        elif opcion == "3":
            if not set(["ethnicity","age"]).issubset(df.columns):
                print("Faltan columnas 'ethnicity' o 'age'.")
                continue
            promedio = df.groupby("ethnicity")["age"].mean()
            ax = promedio.plot(kind="bar")
            ax.set_title("Promedio de edad por etnia")
            ax.set_xlabel("Etnia")
            ax.set_ylabel("Edad promedio")
            ruta = os.path.join(OUTPUT_DIR, "graf_barras_edad_por_etnia.png")
            plt.savefig(ruta, dpi=120, bbox_inches="tight")
            plt.show()
            print(f"Gráfica guardada en: {ruta}")
            agregar_hallazgo("Gráfica de edad promedio por etnia guardada.")

        elif opcion == "4":
            break


# -------------------------------
# CONFIGURACIÓN / CARGA EXTRA
# -------------------------------
def configurar_datos():
    """
    Menú para cargar el segundo CSV o volver a descargar el principal.
    """
    while True:
        print("\n CONFIGURAR DATOS ")
        print("1. Volver a cargar dataset principal (Kaggle o ruta)")
        print("2. Cargar CSV secundario (para merge)")
        print("3. Volver")
        op = input_opcion("> ", {"1","2","3"})
        if op == "1":
            cargar_dataset_principal()
        elif op == "2":
            cargar_dataset_secundario()
        elif op == "3":
            break


# -------------------------------
# MENÚ PRINCIPAL
# -------------------------------
def menu_principal():
    global df
    print(f"{VERSION_INFO[0]}: {VERSION_INFO[1]}")  # Tupla en uso

    # Carga inicial (misma lógica del compa)
    cargar_dataset_principal()

    while True:
        print("\n PROYECTO INTEGRADOR - ANÁLISIS DE DATOS ")
        print("1. Estadísticas")
        print("2. Reportes")
        print("3. Gráficas")
        print("4. Guardar resumen (TXT)  [Puntos extra]")
        print("5. Configurar datos (cargar 2º CSV, etc.)")
        print("6. Salir")

        opcion = input_opcion("Selecciona una opción: ", {"1","2","3","4","5","6"})

        if opcion == "1":
            estadistica()
        elif opcion == "2":
            reporte()
        elif opcion == "3":
            grafica()
        elif opcion == "4":
            guardar_resumen_txt()
        elif opcion == "5":
            configurar_datos()
        elif opcion == "6":
            print("Hasta pronto!")
            break


# -------------------------------
# EJECUCIÓN
# -------------------------------
menu_principal()

# -------------------------------
# PLAN DE PRUEBAS (COMENTARIOS)
# -------------------------------
# 1) Carga inicial: verificar que se descargue y abra age_gender.csv; columnas mostradas.
# 2) Estadística #1: promedio de edad por género tras filtro age [20,40]; esperar tabla con dos filas.
# 3) Estadística #4: correlación entre dos numéricas (age vs age para probar -> r=1.0).
# 4) Configurar datos -> Cargar CSV secundario (por ejemplo otro CSV con 'gender' o clave 'img_name') y hacer MERGE por llave válida; luego correlación.
# 5) Reporte #4: crosstab entre 'gender' y 'ethnicity'; verificar que imprima DataFrame y también la lista de listas (matriz) sin error.
# 6) Reporte #5: comparar categorías entre df y df2 con conjuntos; revisar intersección y diferencias.
# 7) Gráficas #1, #2, #3: verificar que se guarden tres PNG en /output.
# 8) Guardar resumen: confirmar creación de /output/resumen.txt con líneas de hallazgos acumulados.

